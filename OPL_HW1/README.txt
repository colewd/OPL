Cole DiStasio
cole_distasio@student.uml.edu

Running python:
	In terminal- 
		python OPL_HW1.py
Running Prolog:
	In terminal-
		swipl -s properm.pl
		permut_clpfd(L, N), writeIn(L), fail. (change N to # of elements you want)
		press y when prompted
Running Haskell:
   	ghci perm-haskell.hs
	:l perm-haskell.hs
	perms n

Running Go:
	go run perm-go.go n

Running Ada:
	$ gnatmake generic_perm.adb
	$ gnatmake print_perms.adb
	$ ./Print_Perms 3



 

What was easy?
	ada- It wasn't
	Haskell- The recursive solution was surprisingly easy to write for this one despite not being very familiar with the language.
	Go- A lot of similarities to C made it easy to read and understand.
	Python- The syntax is easy to learn and didn't take much time to get used to.
	Prolog- There wasn't much actual code that was required to get the permutations.
What was hard?
	ada- trying to compile it gave us a lot of trouble.
	Haskell- Debugging was difficult.
	Go- found it to be pretty simple due to similarities.
	Python- Ran in to a few errors when I was first getting used to the syntax, specically with types. 
	Prolog- The syntax was very different from what I was used to so it took a while to understand how to make things work.
Are there noticable differences in speed?
	ada- Very quick
	Haskell- quick
	Go- average
	Python- Took a while when compiling with even a small amount of list elements.
	Prolog- Very quick
What do you like/dislike?
	ada- disliked everything!
	Haskell- found it difficult using arrays
	Go- like that it's very familiar and written very similarly to how it would be done in C.
	Python- Liked how similar it was to C++ and that I could easily understand how everything worked. 
	Prolog- Liked how quickly it ran. Disliked the syntax, ran into a lot of errors, had trouble initially getting it to run.
Did you find iterators to be helpful?
	ada- no were't helpful.
	Go- Yes and easy to implement.
	Python- Yes and they work syntactically almost exactly how I was used to.